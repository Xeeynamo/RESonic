#include "VideoD3D9.h"
#include "Window.h"
#include "File.h"

#pragma comment(lib, "d3d9.lib")

namespace XeEngine
{
	namespace VideoFramework
	{
		const D3DFORMAT D3D9::c_pixelformat[] =
		{
			D3DFMT_A8R8G8B8,	// VideoPixelFormat_RGBA8888
			D3DFMT_R8G8B8,		// VideoPixelFormat_RGB888
			D3DFMT_A8R8G8B8,	// VideoPixelFormat_RGBA4444
			D3DFMT_A1R5G5B5,	// VideoPixelFormat_RGB5A1
			D3DFMT_R5G6B5,		// VideoPixelFormat_RGB565
			D3DFMT_A8,			// VideoPixelFormat_A8
			D3DFMT_A8L8,		// VideoPixelFormat_AI88
		};
		const D3DPRIMITIVETYPE D3D9::c_primitives[] =
		{
			D3DPT_POINTLIST,		// RenderType_Point (not minimal)
			D3DPT_LINELIST,			// RenderPrimitives_LineList
			D3DPT_LINESTRIP,		// RenderPrimitives_LineStrip
			D3DPT_TRIANGLELIST,		// RenderPrimitives_TriangleList
			D3DPT_TRIANGLESTRIP,	// RenderPrimitives_TriangleStrip
			D3DPT_TRIANGLEFAN,		// RenderType_TriangleFan (not minimal)
		};
		const char D3D9::d3d9ShaderFx[] = {
			0x00, 0x02, 0xFF, 0xFF, 0xFE, 0xFF, 0x22, 0x00, 0x43, 0x54, 0x41, 0x42, 0x1C, 0x00, 0x00, 0x00,
			0x4F, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
			0x00, 0x01, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x02, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xAB, 0xAB, 0xAB, 0x04, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0xAB,
			0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x03, 0xB0, 0x1F, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x90, 0x00, 0x08, 0x0F, 0xA0, 0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80,
			0x00, 0x00, 0xE4, 0xB0, 0x00, 0x08, 0xE4, 0xA0, 0x01, 0x00, 0x00, 0x02, 0x00, 0x08, 0x0F, 0x80,
			0x00, 0x00, 0xE4, 0x80, 0xFF, 0xFF, 0x00, 0x00
		};
		const char D3D9::d3d9ShaderFxPalette[] = {
			0x00, 0x02, 0xFF, 0xFF, 0xFE, 0xFF, 0x2D, 0x00, 0x43, 0x54, 0x41, 0x42, 0x1C, 0x00, 0x00, 0x00,
			0x7B, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFF, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
			0x00, 0x01, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x02, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
			0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0xAB, 0xAB, 0x04, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0xAB, 0xAB,
			0x04, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0xAB, 0x1F, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0xB0, 0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x0F, 0x90, 0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x08, 0x0F, 0xA0,
			0x1F, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x90, 0x01, 0x08, 0x0F, 0xA0, 0x42, 0x00, 0x00, 0x03,
			0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0xB0, 0x00, 0x08, 0xE4, 0xA0, 0x01, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xFF, 0x80, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x80,
			0x00, 0x00, 0xAA, 0xB0, 0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x00, 0xE4, 0x80,
			0x01, 0x08, 0xE4, 0xA0, 0x05, 0x00, 0x00, 0x03, 0x01, 0x00, 0x09, 0x80, 0x00, 0x00, 0xE4, 0x80,
			0x00, 0x00, 0xD2, 0x90, 0x05, 0x00, 0x00, 0x03, 0x01, 0x00, 0x04, 0x80, 0x00, 0x00, 0xAA, 0x80,
			0x00, 0x00, 0x00, 0x90, 0x05, 0x00, 0x00, 0x03, 0x01, 0x00, 0x02, 0x80, 0x00, 0x00, 0x55, 0x80,
			0x00, 0x00, 0x55, 0x90, 0x01, 0x00, 0x00, 0x02, 0x00, 0x08, 0x0F, 0x80, 0x01, 0x00, 0xE4, 0x80,
			0xFF, 0xFF, 0x00, 0x00
		};


		D3D9::D3D9(Window* window) : Video(window)
		{
			m_name = "Direct3D9";
			p_d3d9 = nullptr;
			p_device = nullptr;
			p_pixelShader = nullptr;
			m_clearColor = 0;
			m_windowed = true;
			ZeroMemory(&m_caps, sizeof(m_caps));
			ZeroMemory(&m_pp, sizeof(m_pp));
		}
		D3D9::~D3D9()
		{
			if (p_pixelShader != nullptr) p_pixelShader->Release();
			if (p_device != nullptr) p_device->Release();
			if (p_d3d9 != nullptr) p_d3d9->Release();
		}
		bool D3D9::_Initialize()
		{
			p_d3d9 = Direct3DCreate9(D3D_SDK_VERSION); 
			if (p_d3d9 == nullptr)
			{
				m_window->ShowMessage(Window::MessageBoxType_Error, Window::MessageBoxButtons_Ok,
					"Direct3DCreate9 failed.");
				return false;
			}
			D3DDISPLAYMODE m_displayMode;
			p_d3d9->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &m_displayMode );
			p_d3d9->GetDeviceCaps( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &m_caps );

			DWORD vertexProcessing = 0;
			if ( m_caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT )
			{
				vertexProcessing = D3DCREATE_HARDWARE_VERTEXPROCESSING;

				if ( m_caps.DevCaps & D3DDEVCAPS_PUREDEVICE )
				{
					vertexProcessing |= D3DCREATE_PUREDEVICE;
				}
			}
			else
			{
				vertexProcessing = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
			}
			D3D9BuildPP();
			if (FAILED(p_d3d9->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
				(HWND)m_window->GetHandle(), vertexProcessing, &m_pp, &p_device )))
			{
				m_window->ShowMessage(Window::MessageBoxType_Error, Window::MessageBoxButtons_Ok,
					"CreateDevice failed.");
				return false;
			}
			D3D9Reset();
			return true;
		}
		void D3D9::_SetClearColor(const float r, const float g, const float b)
		{
			m_clearColor = D3DCOLOR_XRGB( (DWORD)(r * 255.0f), (DWORD)(g * 255.0f), (DWORD)(b * 255.0f) );
		}
		void D3D9::_RenderBegin()
		{
			HRESULT hErr = p_device->TestCooperativeLevel();
			if (FAILED(hErr))
			{
				if (hErr == D3DERR_DEVICELOST)
				{
					con.Log(DEBUG_LEVEL_WARNING, "D3D9 device lost");
					con.Log(DEBUG_LEVEL_HIGHPRIORITY, "please implement System::Sleep on _RenderBegin()");
				}
				D3D9Reset();
				return;
			}

			p_device->Clear( 0, 0, D3DCLEAR_TARGET, m_clearColor, 1.0f, 0 );
			p_device->BeginScene();
		}
		void D3D9::_RenderEnd()
		{
			p_device->EndScene();
			p_device->Present(nullptr, nullptr, nullptr, nullptr);
		}
		void D3D9::_SendVertices(const Vertex* data, const size_t count, const Primitives primitives)
		{
			p_device->DrawPrimitiveUP(c_primitives[primitives], GetVertexCount(primitives, count), data, sizeof(Vertex) );
		}
		void D3D9::_SendIndexedVertices(const Vertex* data, const u16* indices, const size_t count, const Primitives primitives)
		{
			p_device->DrawIndexedPrimitiveUP(c_primitives[primitives], 0, count * 2, count, indices, D3DFMT_INDEX16, data, sizeof(Vertex) );
		}
		bool D3D9::_UploadTexture(TextureID& id, const u16 width, const u16 height, const PixelFormat format, void* data)
		{
			LPDIRECT3DTEXTURE9 pd3dTexture = (LPDIRECT3DTEXTURE9)id;
			if (pd3dTexture == nullptr)
			{
				HRESULT hRes = p_device->CreateTexture(width, height, 1, 0, c_pixelformat[format], D3DPOOL_MANAGED, &pd3dTexture, NULL);
				id = (size_t)pd3dTexture;
				return !FAILED(hRes);
			}
			else
			{
				D3DLOCKED_RECT rect;
				if (pd3dTexture->LockRect(0, &rect, nullptr, 0) != S_OK) return false;
				memcpy(rect.pBits, data, rect.Pitch * height);
				pd3dTexture->UnlockRect(0);
				return true;
			}
		}
		void D3D9::_DeleteTexture(TextureID& id)
		{
			if (id != 0)
			{
				((LPDIRECT3DTEXTURE9)id)->Release();
				id = 0;
			}
		}
		void D3D9::_SelectTexture(TextureID& id)
		{
			p_device->SetTexture(0, (LPDIRECT3DTEXTURE9)id);
		}
		void D3D9::_UsePalette(const bool palette)
		{
			p_device->SetPixelShader(palette ? p_pixelclutShader : p_pixelShader);
		}
		void D3D9::_SelectPalette(const TextureID& id)
		{
			p_device->SetTexture(1, (LPDIRECT3DTEXTURE9)id);
		}

		void D3D9::D3D9BuildPP()
		{
			Window::Size size;
			m_window->GetSize(size);

			m_pp.AutoDepthStencilFormat		= D3DFMT_D16;
			m_pp.BackBufferWidth            = (m_windowed) ? 0 : size.x;
			m_pp.BackBufferHeight           = (m_windowed) ? 0 : size.y;
			m_pp.BackBufferFormat           = D3DFMT_X8R8G8B8;
			m_pp.BackBufferCount            = 1;
			m_pp.MultiSampleType            = D3DMULTISAMPLE_NONE;
			m_pp.MultiSampleQuality         = 0;
			m_pp.SwapEffect                 = D3DSWAPEFFECT_DISCARD; 
			m_pp.hDeviceWindow              = (HWND)m_window->GetHandle();
			m_pp.Windowed                   = m_windowed;
			m_pp.EnableAutoDepthStencil     = TRUE; 
			m_pp.FullScreen_RefreshRateInHz = (m_windowed) ? 0 : 60;
			//m_pp.PresentationInterval       = D3DPRESENT_INTERVAL_IMMEDIATE;
		}
		void D3D9::D3D9Reset()
		{
			D3DVERTEXELEMENT9 vertexElement[] =
			{
				{ 0,  0, D3DDECLTYPE_FLOAT2,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
				{ 0,  8, D3DDECLTYPE_FLOAT3,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
				{ 0,  20, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,   0 },
				D3DDECL_END()
			};

			LPDIRECT3DVERTEXDECLARATION9 vertexDeclaration = 0;
			p_device->CreateVertexDeclaration( vertexElement, &vertexDeclaration );
			p_device->SetVertexDeclaration( vertexDeclaration );

			// Create shaders
			File fileTmp;
			Memory memTmp;

			p_device->CreatePixelShader((const DWORD*)d3d9ShaderFx, &p_pixelShader);
			p_device->CreatePixelShader((const DWORD*)d3d9ShaderFxPalette, &p_pixelclutShader);
			UsePalette(false);

			// Set up the render states
			p_device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
			p_device->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
			p_device->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
			p_device->SetRenderState( D3DRS_LIGHTING, FALSE );
		}
	}
}